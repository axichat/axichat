// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Message {
  String get stanzaID => throw _privateConstructorUsedError;
  String get myJid => throw _privateConstructorUsedError;
  String get senderJid => throw _privateConstructorUsedError;
  String get chatJid => throw _privateConstructorUsedError;
  DateTime? get timestamp => throw _privateConstructorUsedError;
  String? get id => throw _privateConstructorUsedError;
  String? get originID => throw _privateConstructorUsedError;
  String? get occupantID => throw _privateConstructorUsedError;
  String? get body => throw _privateConstructorUsedError;
  MessageError get error => throw _privateConstructorUsedError;
  MessageWarning get warning => throw _privateConstructorUsedError;
  bool get encrypted => throw _privateConstructorUsedError;
  bool get noStore => throw _privateConstructorUsedError;
  bool get acked => throw _privateConstructorUsedError;
  bool get received => throw _privateConstructorUsedError;
  bool get displayed => throw _privateConstructorUsedError;
  bool get edited => throw _privateConstructorUsedError;
  bool get retracted => throw _privateConstructorUsedError;
  bool get isFileUploadNotification => throw _privateConstructorUsedError;
  bool get fileDownloading => throw _privateConstructorUsedError;
  bool get fileUploading => throw _privateConstructorUsedError;
  String? get fileMetadataID => throw _privateConstructorUsedError;
  String? get quoting => throw _privateConstructorUsedError;
  String? get stickerPackID => throw _privateConstructorUsedError;
  PseudoMessageType? get pseudoMessageType =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get pseudoMessageData =>
      throw _privateConstructorUsedError;
  List<String> get reactionsPreview => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)
        $default, {
    required TResult Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)
        fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        $default, {
    TResult? Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        $default, {
    TResult Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        fromDb,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Message value) $default, {
    required TResult Function(_MessageFromDb value) fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Message value)? $default, {
    TResult? Function(_MessageFromDb value)? fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Message value)? $default, {
    TResult Function(_MessageFromDb value)? fromDb,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MessageCopyWith<Message> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MessageCopyWith<$Res> {
  factory $MessageCopyWith(Message value, $Res Function(Message) then) =
      _$MessageCopyWithImpl<$Res, Message>;
  @useResult
  $Res call(
      {String stanzaID,
      String myJid,
      String senderJid,
      String chatJid,
      DateTime timestamp,
      String id,
      String? originID,
      String? occupantID,
      String? body,
      MessageError error,
      MessageWarning warning,
      bool encrypted,
      bool noStore,
      bool acked,
      bool received,
      bool displayed,
      bool edited,
      bool retracted,
      bool isFileUploadNotification,
      bool fileDownloading,
      bool fileUploading,
      String? fileMetadataID,
      String? quoting,
      String? stickerPackID,
      PseudoMessageType? pseudoMessageType,
      Map<String, dynamic>? pseudoMessageData,
      List<String> reactionsPreview});
}

/// @nodoc
class _$MessageCopyWithImpl<$Res, $Val extends Message>
    implements $MessageCopyWith<$Res> {
  _$MessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stanzaID = null,
    Object? myJid = null,
    Object? senderJid = null,
    Object? chatJid = null,
    Object? timestamp = null,
    Object? id = null,
    Object? originID = freezed,
    Object? occupantID = freezed,
    Object? body = freezed,
    Object? error = null,
    Object? warning = null,
    Object? encrypted = null,
    Object? noStore = null,
    Object? acked = null,
    Object? received = null,
    Object? displayed = null,
    Object? edited = null,
    Object? retracted = null,
    Object? isFileUploadNotification = null,
    Object? fileDownloading = null,
    Object? fileUploading = null,
    Object? fileMetadataID = freezed,
    Object? quoting = freezed,
    Object? stickerPackID = freezed,
    Object? pseudoMessageType = freezed,
    Object? pseudoMessageData = freezed,
    Object? reactionsPreview = null,
  }) {
    return _then(_value.copyWith(
      stanzaID: null == stanzaID
          ? _value.stanzaID
          : stanzaID // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderJid: null == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String,
      chatJid: null == chatJid
          ? _value.chatJid
          : chatJid // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp!
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      id: null == id
          ? _value.id!
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      originID: freezed == originID
          ? _value.originID
          : originID // ignore: cast_nullable_to_non_nullable
              as String?,
      occupantID: freezed == occupantID
          ? _value.occupantID
          : occupantID // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as MessageError,
      warning: null == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as MessageWarning,
      encrypted: null == encrypted
          ? _value.encrypted
          : encrypted // ignore: cast_nullable_to_non_nullable
              as bool,
      noStore: null == noStore
          ? _value.noStore
          : noStore // ignore: cast_nullable_to_non_nullable
              as bool,
      acked: null == acked
          ? _value.acked
          : acked // ignore: cast_nullable_to_non_nullable
              as bool,
      received: null == received
          ? _value.received
          : received // ignore: cast_nullable_to_non_nullable
              as bool,
      displayed: null == displayed
          ? _value.displayed
          : displayed // ignore: cast_nullable_to_non_nullable
              as bool,
      edited: null == edited
          ? _value.edited
          : edited // ignore: cast_nullable_to_non_nullable
              as bool,
      retracted: null == retracted
          ? _value.retracted
          : retracted // ignore: cast_nullable_to_non_nullable
              as bool,
      isFileUploadNotification: null == isFileUploadNotification
          ? _value.isFileUploadNotification
          : isFileUploadNotification // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDownloading: null == fileDownloading
          ? _value.fileDownloading
          : fileDownloading // ignore: cast_nullable_to_non_nullable
              as bool,
      fileUploading: null == fileUploading
          ? _value.fileUploading
          : fileUploading // ignore: cast_nullable_to_non_nullable
              as bool,
      fileMetadataID: freezed == fileMetadataID
          ? _value.fileMetadataID
          : fileMetadataID // ignore: cast_nullable_to_non_nullable
              as String?,
      quoting: freezed == quoting
          ? _value.quoting
          : quoting // ignore: cast_nullable_to_non_nullable
              as String?,
      stickerPackID: freezed == stickerPackID
          ? _value.stickerPackID
          : stickerPackID // ignore: cast_nullable_to_non_nullable
              as String?,
      pseudoMessageType: freezed == pseudoMessageType
          ? _value.pseudoMessageType
          : pseudoMessageType // ignore: cast_nullable_to_non_nullable
              as PseudoMessageType?,
      pseudoMessageData: freezed == pseudoMessageData
          ? _value.pseudoMessageData
          : pseudoMessageData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      reactionsPreview: null == reactionsPreview
          ? _value.reactionsPreview
          : reactionsPreview // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MessageImplCopyWith<$Res> implements $MessageCopyWith<$Res> {
  factory _$$MessageImplCopyWith(
          _$MessageImpl value, $Res Function(_$MessageImpl) then) =
      __$$MessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String stanzaID,
      String myJid,
      String senderJid,
      String chatJid,
      DateTime? timestamp,
      String? id,
      String? originID,
      String? occupantID,
      String? body,
      MessageError error,
      MessageWarning warning,
      bool encrypted,
      bool noStore,
      bool acked,
      bool received,
      bool displayed,
      bool edited,
      bool retracted,
      bool isFileUploadNotification,
      bool fileDownloading,
      bool fileUploading,
      String? fileMetadataID,
      String? quoting,
      String? stickerPackID,
      PseudoMessageType? pseudoMessageType,
      Map<String, dynamic>? pseudoMessageData,
      List<String> reactionsPreview});
}

/// @nodoc
class __$$MessageImplCopyWithImpl<$Res>
    extends _$MessageCopyWithImpl<$Res, _$MessageImpl>
    implements _$$MessageImplCopyWith<$Res> {
  __$$MessageImplCopyWithImpl(
      _$MessageImpl _value, $Res Function(_$MessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stanzaID = null,
    Object? myJid = null,
    Object? senderJid = null,
    Object? chatJid = null,
    Object? timestamp = freezed,
    Object? id = freezed,
    Object? originID = freezed,
    Object? occupantID = freezed,
    Object? body = freezed,
    Object? error = null,
    Object? warning = null,
    Object? encrypted = null,
    Object? noStore = null,
    Object? acked = null,
    Object? received = null,
    Object? displayed = null,
    Object? edited = null,
    Object? retracted = null,
    Object? isFileUploadNotification = null,
    Object? fileDownloading = null,
    Object? fileUploading = null,
    Object? fileMetadataID = freezed,
    Object? quoting = freezed,
    Object? stickerPackID = freezed,
    Object? pseudoMessageType = freezed,
    Object? pseudoMessageData = freezed,
    Object? reactionsPreview = null,
  }) {
    return _then(_$MessageImpl(
      stanzaID: null == stanzaID
          ? _value.stanzaID
          : stanzaID // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderJid: null == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String,
      chatJid: null == chatJid
          ? _value.chatJid
          : chatJid // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: freezed == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      originID: freezed == originID
          ? _value.originID
          : originID // ignore: cast_nullable_to_non_nullable
              as String?,
      occupantID: freezed == occupantID
          ? _value.occupantID
          : occupantID // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as MessageError,
      warning: null == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as MessageWarning,
      encrypted: null == encrypted
          ? _value.encrypted
          : encrypted // ignore: cast_nullable_to_non_nullable
              as bool,
      noStore: null == noStore
          ? _value.noStore
          : noStore // ignore: cast_nullable_to_non_nullable
              as bool,
      acked: null == acked
          ? _value.acked
          : acked // ignore: cast_nullable_to_non_nullable
              as bool,
      received: null == received
          ? _value.received
          : received // ignore: cast_nullable_to_non_nullable
              as bool,
      displayed: null == displayed
          ? _value.displayed
          : displayed // ignore: cast_nullable_to_non_nullable
              as bool,
      edited: null == edited
          ? _value.edited
          : edited // ignore: cast_nullable_to_non_nullable
              as bool,
      retracted: null == retracted
          ? _value.retracted
          : retracted // ignore: cast_nullable_to_non_nullable
              as bool,
      isFileUploadNotification: null == isFileUploadNotification
          ? _value.isFileUploadNotification
          : isFileUploadNotification // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDownloading: null == fileDownloading
          ? _value.fileDownloading
          : fileDownloading // ignore: cast_nullable_to_non_nullable
              as bool,
      fileUploading: null == fileUploading
          ? _value.fileUploading
          : fileUploading // ignore: cast_nullable_to_non_nullable
              as bool,
      fileMetadataID: freezed == fileMetadataID
          ? _value.fileMetadataID
          : fileMetadataID // ignore: cast_nullable_to_non_nullable
              as String?,
      quoting: freezed == quoting
          ? _value.quoting
          : quoting // ignore: cast_nullable_to_non_nullable
              as String?,
      stickerPackID: freezed == stickerPackID
          ? _value.stickerPackID
          : stickerPackID // ignore: cast_nullable_to_non_nullable
              as String?,
      pseudoMessageType: freezed == pseudoMessageType
          ? _value.pseudoMessageType
          : pseudoMessageType // ignore: cast_nullable_to_non_nullable
              as PseudoMessageType?,
      pseudoMessageData: freezed == pseudoMessageData
          ? _value._pseudoMessageData
          : pseudoMessageData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      reactionsPreview: null == reactionsPreview
          ? _value._reactionsPreview
          : reactionsPreview // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$MessageImpl extends _Message {
  const _$MessageImpl(
      {required this.stanzaID,
      required this.myJid,
      required this.senderJid,
      required this.chatJid,
      this.timestamp,
      this.id,
      this.originID,
      this.occupantID,
      this.body,
      this.error = MessageError.none,
      this.warning = MessageWarning.none,
      this.encrypted = false,
      this.noStore = false,
      this.acked = false,
      this.received = false,
      this.displayed = false,
      this.edited = false,
      this.retracted = false,
      this.isFileUploadNotification = false,
      this.fileDownloading = false,
      this.fileUploading = false,
      this.fileMetadataID,
      this.quoting,
      this.stickerPackID,
      this.pseudoMessageType,
      final Map<String, dynamic>? pseudoMessageData,
      final List<String> reactionsPreview = const <String>[]})
      : _pseudoMessageData = pseudoMessageData,
        _reactionsPreview = reactionsPreview,
        super._();

  @override
  final String stanzaID;
  @override
  final String myJid;
  @override
  final String senderJid;
  @override
  final String chatJid;
  @override
  final DateTime? timestamp;
  @override
  final String? id;
  @override
  final String? originID;
  @override
  final String? occupantID;
  @override
  final String? body;
  @override
  @JsonKey()
  final MessageError error;
  @override
  @JsonKey()
  final MessageWarning warning;
  @override
  @JsonKey()
  final bool encrypted;
  @override
  @JsonKey()
  final bool noStore;
  @override
  @JsonKey()
  final bool acked;
  @override
  @JsonKey()
  final bool received;
  @override
  @JsonKey()
  final bool displayed;
  @override
  @JsonKey()
  final bool edited;
  @override
  @JsonKey()
  final bool retracted;
  @override
  @JsonKey()
  final bool isFileUploadNotification;
  @override
  @JsonKey()
  final bool fileDownloading;
  @override
  @JsonKey()
  final bool fileUploading;
  @override
  final String? fileMetadataID;
  @override
  final String? quoting;
  @override
  final String? stickerPackID;
  @override
  final PseudoMessageType? pseudoMessageType;
  final Map<String, dynamic>? _pseudoMessageData;
  @override
  Map<String, dynamic>? get pseudoMessageData {
    final value = _pseudoMessageData;
    if (value == null) return null;
    if (_pseudoMessageData is EqualUnmodifiableMapView)
      return _pseudoMessageData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<String> _reactionsPreview;
  @override
  @JsonKey()
  List<String> get reactionsPreview {
    if (_reactionsPreview is EqualUnmodifiableListView)
      return _reactionsPreview;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reactionsPreview);
  }

  @override
  String toString() {
    return 'Message(stanzaID: $stanzaID, myJid: $myJid, senderJid: $senderJid, chatJid: $chatJid, timestamp: $timestamp, id: $id, originID: $originID, occupantID: $occupantID, body: $body, error: $error, warning: $warning, encrypted: $encrypted, noStore: $noStore, acked: $acked, received: $received, displayed: $displayed, edited: $edited, retracted: $retracted, isFileUploadNotification: $isFileUploadNotification, fileDownloading: $fileDownloading, fileUploading: $fileUploading, fileMetadataID: $fileMetadataID, quoting: $quoting, stickerPackID: $stickerPackID, pseudoMessageType: $pseudoMessageType, pseudoMessageData: $pseudoMessageData, reactionsPreview: $reactionsPreview)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageImpl &&
            (identical(other.stanzaID, stanzaID) ||
                other.stanzaID == stanzaID) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.senderJid, senderJid) ||
                other.senderJid == senderJid) &&
            (identical(other.chatJid, chatJid) || other.chatJid == chatJid) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.originID, originID) ||
                other.originID == originID) &&
            (identical(other.occupantID, occupantID) ||
                other.occupantID == occupantID) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.warning, warning) || other.warning == warning) &&
            (identical(other.encrypted, encrypted) ||
                other.encrypted == encrypted) &&
            (identical(other.noStore, noStore) || other.noStore == noStore) &&
            (identical(other.acked, acked) || other.acked == acked) &&
            (identical(other.received, received) ||
                other.received == received) &&
            (identical(other.displayed, displayed) ||
                other.displayed == displayed) &&
            (identical(other.edited, edited) || other.edited == edited) &&
            (identical(other.retracted, retracted) ||
                other.retracted == retracted) &&
            (identical(
                    other.isFileUploadNotification, isFileUploadNotification) ||
                other.isFileUploadNotification == isFileUploadNotification) &&
            (identical(other.fileDownloading, fileDownloading) ||
                other.fileDownloading == fileDownloading) &&
            (identical(other.fileUploading, fileUploading) ||
                other.fileUploading == fileUploading) &&
            (identical(other.fileMetadataID, fileMetadataID) ||
                other.fileMetadataID == fileMetadataID) &&
            (identical(other.quoting, quoting) || other.quoting == quoting) &&
            (identical(other.stickerPackID, stickerPackID) ||
                other.stickerPackID == stickerPackID) &&
            (identical(other.pseudoMessageType, pseudoMessageType) ||
                other.pseudoMessageType == pseudoMessageType) &&
            const DeepCollectionEquality()
                .equals(other._pseudoMessageData, _pseudoMessageData) &&
            const DeepCollectionEquality()
                .equals(other._reactionsPreview, _reactionsPreview));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        stanzaID,
        myJid,
        senderJid,
        chatJid,
        timestamp,
        id,
        originID,
        occupantID,
        body,
        error,
        warning,
        encrypted,
        noStore,
        acked,
        received,
        displayed,
        edited,
        retracted,
        isFileUploadNotification,
        fileDownloading,
        fileUploading,
        fileMetadataID,
        quoting,
        stickerPackID,
        pseudoMessageType,
        const DeepCollectionEquality().hash(_pseudoMessageData),
        const DeepCollectionEquality().hash(_reactionsPreview)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageImplCopyWith<_$MessageImpl> get copyWith =>
      __$$MessageImplCopyWithImpl<_$MessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)
        $default, {
    required TResult Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)
        fromDb,
  }) {
    return $default(
        stanzaID,
        myJid,
        senderJid,
        chatJid,
        timestamp,
        id,
        originID,
        occupantID,
        body,
        error,
        warning,
        encrypted,
        noStore,
        acked,
        received,
        displayed,
        edited,
        retracted,
        isFileUploadNotification,
        fileDownloading,
        fileUploading,
        fileMetadataID,
        quoting,
        stickerPackID,
        pseudoMessageType,
        pseudoMessageData,
        reactionsPreview);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        $default, {
    TResult? Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        fromDb,
  }) {
    return $default?.call(
        stanzaID,
        myJid,
        senderJid,
        chatJid,
        timestamp,
        id,
        originID,
        occupantID,
        body,
        error,
        warning,
        encrypted,
        noStore,
        acked,
        received,
        displayed,
        edited,
        retracted,
        isFileUploadNotification,
        fileDownloading,
        fileUploading,
        fileMetadataID,
        quoting,
        stickerPackID,
        pseudoMessageType,
        pseudoMessageData,
        reactionsPreview);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        $default, {
    TResult Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        fromDb,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(
          stanzaID,
          myJid,
          senderJid,
          chatJid,
          timestamp,
          id,
          originID,
          occupantID,
          body,
          error,
          warning,
          encrypted,
          noStore,
          acked,
          received,
          displayed,
          edited,
          retracted,
          isFileUploadNotification,
          fileDownloading,
          fileUploading,
          fileMetadataID,
          quoting,
          stickerPackID,
          pseudoMessageType,
          pseudoMessageData,
          reactionsPreview);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Message value) $default, {
    required TResult Function(_MessageFromDb value) fromDb,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Message value)? $default, {
    TResult? Function(_MessageFromDb value)? fromDb,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Message value)? $default, {
    TResult Function(_MessageFromDb value)? fromDb,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _Message extends Message {
  const factory _Message(
      {required final String stanzaID,
      required final String myJid,
      required final String senderJid,
      required final String chatJid,
      final DateTime? timestamp,
      final String? id,
      final String? originID,
      final String? occupantID,
      final String? body,
      final MessageError error,
      final MessageWarning warning,
      final bool encrypted,
      final bool noStore,
      final bool acked,
      final bool received,
      final bool displayed,
      final bool edited,
      final bool retracted,
      final bool isFileUploadNotification,
      final bool fileDownloading,
      final bool fileUploading,
      final String? fileMetadataID,
      final String? quoting,
      final String? stickerPackID,
      final PseudoMessageType? pseudoMessageType,
      final Map<String, dynamic>? pseudoMessageData,
      final List<String> reactionsPreview}) = _$MessageImpl;
  const _Message._() : super._();

  @override
  String get stanzaID;
  @override
  String get myJid;
  @override
  String get senderJid;
  @override
  String get chatJid;
  @override
  DateTime? get timestamp;
  @override
  String? get id;
  @override
  String? get originID;
  @override
  String? get occupantID;
  @override
  String? get body;
  @override
  MessageError get error;
  @override
  MessageWarning get warning;
  @override
  bool get encrypted;
  @override
  bool get noStore;
  @override
  bool get acked;
  @override
  bool get received;
  @override
  bool get displayed;
  @override
  bool get edited;
  @override
  bool get retracted;
  @override
  bool get isFileUploadNotification;
  @override
  bool get fileDownloading;
  @override
  bool get fileUploading;
  @override
  String? get fileMetadataID;
  @override
  String? get quoting;
  @override
  String? get stickerPackID;
  @override
  PseudoMessageType? get pseudoMessageType;
  @override
  Map<String, dynamic>? get pseudoMessageData;
  @override
  List<String> get reactionsPreview;
  @override
  @JsonKey(ignore: true)
  _$$MessageImplCopyWith<_$MessageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MessageFromDbImplCopyWith<$Res>
    implements $MessageCopyWith<$Res> {
  factory _$$MessageFromDbImplCopyWith(
          _$MessageFromDbImpl value, $Res Function(_$MessageFromDbImpl) then) =
      __$$MessageFromDbImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String stanzaID,
      String? originID,
      String? occupantID,
      String myJid,
      String senderJid,
      String chatJid,
      String? body,
      DateTime timestamp,
      MessageError error,
      MessageWarning warning,
      bool encrypted,
      bool noStore,
      bool acked,
      bool received,
      bool displayed,
      bool edited,
      bool retracted,
      bool isFileUploadNotification,
      bool fileDownloading,
      bool fileUploading,
      String? fileMetadataID,
      String? quoting,
      String? stickerPackID,
      PseudoMessageType? pseudoMessageType,
      Map<String, dynamic>? pseudoMessageData,
      List<String> reactionsPreview});
}

/// @nodoc
class __$$MessageFromDbImplCopyWithImpl<$Res>
    extends _$MessageCopyWithImpl<$Res, _$MessageFromDbImpl>
    implements _$$MessageFromDbImplCopyWith<$Res> {
  __$$MessageFromDbImplCopyWithImpl(
      _$MessageFromDbImpl _value, $Res Function(_$MessageFromDbImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? stanzaID = null,
    Object? originID = freezed,
    Object? occupantID = freezed,
    Object? myJid = null,
    Object? senderJid = null,
    Object? chatJid = null,
    Object? body = freezed,
    Object? timestamp = null,
    Object? error = null,
    Object? warning = null,
    Object? encrypted = null,
    Object? noStore = null,
    Object? acked = null,
    Object? received = null,
    Object? displayed = null,
    Object? edited = null,
    Object? retracted = null,
    Object? isFileUploadNotification = null,
    Object? fileDownloading = null,
    Object? fileUploading = null,
    Object? fileMetadataID = freezed,
    Object? quoting = freezed,
    Object? stickerPackID = freezed,
    Object? pseudoMessageType = freezed,
    Object? pseudoMessageData = freezed,
    Object? reactionsPreview = null,
  }) {
    return _then(_$MessageFromDbImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      stanzaID: null == stanzaID
          ? _value.stanzaID
          : stanzaID // ignore: cast_nullable_to_non_nullable
              as String,
      originID: freezed == originID
          ? _value.originID
          : originID // ignore: cast_nullable_to_non_nullable
              as String?,
      occupantID: freezed == occupantID
          ? _value.occupantID
          : occupantID // ignore: cast_nullable_to_non_nullable
              as String?,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderJid: null == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String,
      chatJid: null == chatJid
          ? _value.chatJid
          : chatJid // ignore: cast_nullable_to_non_nullable
              as String,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as MessageError,
      warning: null == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as MessageWarning,
      encrypted: null == encrypted
          ? _value.encrypted
          : encrypted // ignore: cast_nullable_to_non_nullable
              as bool,
      noStore: null == noStore
          ? _value.noStore
          : noStore // ignore: cast_nullable_to_non_nullable
              as bool,
      acked: null == acked
          ? _value.acked
          : acked // ignore: cast_nullable_to_non_nullable
              as bool,
      received: null == received
          ? _value.received
          : received // ignore: cast_nullable_to_non_nullable
              as bool,
      displayed: null == displayed
          ? _value.displayed
          : displayed // ignore: cast_nullable_to_non_nullable
              as bool,
      edited: null == edited
          ? _value.edited
          : edited // ignore: cast_nullable_to_non_nullable
              as bool,
      retracted: null == retracted
          ? _value.retracted
          : retracted // ignore: cast_nullable_to_non_nullable
              as bool,
      isFileUploadNotification: null == isFileUploadNotification
          ? _value.isFileUploadNotification
          : isFileUploadNotification // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDownloading: null == fileDownloading
          ? _value.fileDownloading
          : fileDownloading // ignore: cast_nullable_to_non_nullable
              as bool,
      fileUploading: null == fileUploading
          ? _value.fileUploading
          : fileUploading // ignore: cast_nullable_to_non_nullable
              as bool,
      fileMetadataID: freezed == fileMetadataID
          ? _value.fileMetadataID
          : fileMetadataID // ignore: cast_nullable_to_non_nullable
              as String?,
      quoting: freezed == quoting
          ? _value.quoting
          : quoting // ignore: cast_nullable_to_non_nullable
              as String?,
      stickerPackID: freezed == stickerPackID
          ? _value.stickerPackID
          : stickerPackID // ignore: cast_nullable_to_non_nullable
              as String?,
      pseudoMessageType: freezed == pseudoMessageType
          ? _value.pseudoMessageType
          : pseudoMessageType // ignore: cast_nullable_to_non_nullable
              as PseudoMessageType?,
      pseudoMessageData: freezed == pseudoMessageData
          ? _value._pseudoMessageData
          : pseudoMessageData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      reactionsPreview: null == reactionsPreview
          ? _value._reactionsPreview
          : reactionsPreview // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$MessageFromDbImpl extends _MessageFromDb {
  const _$MessageFromDbImpl(
      {required this.id,
      required this.stanzaID,
      required this.originID,
      required this.occupantID,
      required this.myJid,
      required this.senderJid,
      required this.chatJid,
      required this.body,
      required this.timestamp,
      required this.error,
      required this.warning,
      required this.encrypted,
      required this.noStore,
      required this.acked,
      required this.received,
      required this.displayed,
      required this.edited,
      required this.retracted,
      required this.isFileUploadNotification,
      required this.fileDownloading,
      required this.fileUploading,
      required this.fileMetadataID,
      required this.quoting,
      required this.stickerPackID,
      required this.pseudoMessageType,
      required final Map<String, dynamic>? pseudoMessageData,
      final List<String> reactionsPreview = const <String>[]})
      : _pseudoMessageData = pseudoMessageData,
        _reactionsPreview = reactionsPreview,
        super._();

  @override
  final String id;
  @override
  final String stanzaID;
  @override
  final String? originID;
  @override
  final String? occupantID;
  @override
  final String myJid;
  @override
  final String senderJid;
  @override
  final String chatJid;
  @override
  final String? body;
  @override
  final DateTime timestamp;
  @override
  final MessageError error;
  @override
  final MessageWarning warning;
  @override
  final bool encrypted;
  @override
  final bool noStore;
  @override
  final bool acked;
  @override
  final bool received;
  @override
  final bool displayed;
  @override
  final bool edited;
  @override
  final bool retracted;
  @override
  final bool isFileUploadNotification;
  @override
  final bool fileDownloading;
  @override
  final bool fileUploading;
  @override
  final String? fileMetadataID;
  @override
  final String? quoting;
  @override
  final String? stickerPackID;
  @override
  final PseudoMessageType? pseudoMessageType;
  final Map<String, dynamic>? _pseudoMessageData;
  @override
  Map<String, dynamic>? get pseudoMessageData {
    final value = _pseudoMessageData;
    if (value == null) return null;
    if (_pseudoMessageData is EqualUnmodifiableMapView)
      return _pseudoMessageData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<String> _reactionsPreview;
  @override
  @JsonKey()
  List<String> get reactionsPreview {
    if (_reactionsPreview is EqualUnmodifiableListView)
      return _reactionsPreview;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reactionsPreview);
  }

  @override
  String toString() {
    return 'Message.fromDb(id: $id, stanzaID: $stanzaID, originID: $originID, occupantID: $occupantID, myJid: $myJid, senderJid: $senderJid, chatJid: $chatJid, body: $body, timestamp: $timestamp, error: $error, warning: $warning, encrypted: $encrypted, noStore: $noStore, acked: $acked, received: $received, displayed: $displayed, edited: $edited, retracted: $retracted, isFileUploadNotification: $isFileUploadNotification, fileDownloading: $fileDownloading, fileUploading: $fileUploading, fileMetadataID: $fileMetadataID, quoting: $quoting, stickerPackID: $stickerPackID, pseudoMessageType: $pseudoMessageType, pseudoMessageData: $pseudoMessageData, reactionsPreview: $reactionsPreview)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MessageFromDbImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stanzaID, stanzaID) ||
                other.stanzaID == stanzaID) &&
            (identical(other.originID, originID) ||
                other.originID == originID) &&
            (identical(other.occupantID, occupantID) ||
                other.occupantID == occupantID) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.senderJid, senderJid) ||
                other.senderJid == senderJid) &&
            (identical(other.chatJid, chatJid) || other.chatJid == chatJid) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.warning, warning) || other.warning == warning) &&
            (identical(other.encrypted, encrypted) ||
                other.encrypted == encrypted) &&
            (identical(other.noStore, noStore) || other.noStore == noStore) &&
            (identical(other.acked, acked) || other.acked == acked) &&
            (identical(other.received, received) ||
                other.received == received) &&
            (identical(other.displayed, displayed) ||
                other.displayed == displayed) &&
            (identical(other.edited, edited) || other.edited == edited) &&
            (identical(other.retracted, retracted) ||
                other.retracted == retracted) &&
            (identical(
                    other.isFileUploadNotification, isFileUploadNotification) ||
                other.isFileUploadNotification == isFileUploadNotification) &&
            (identical(other.fileDownloading, fileDownloading) ||
                other.fileDownloading == fileDownloading) &&
            (identical(other.fileUploading, fileUploading) ||
                other.fileUploading == fileUploading) &&
            (identical(other.fileMetadataID, fileMetadataID) ||
                other.fileMetadataID == fileMetadataID) &&
            (identical(other.quoting, quoting) || other.quoting == quoting) &&
            (identical(other.stickerPackID, stickerPackID) ||
                other.stickerPackID == stickerPackID) &&
            (identical(other.pseudoMessageType, pseudoMessageType) ||
                other.pseudoMessageType == pseudoMessageType) &&
            const DeepCollectionEquality()
                .equals(other._pseudoMessageData, _pseudoMessageData) &&
            const DeepCollectionEquality()
                .equals(other._reactionsPreview, _reactionsPreview));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        stanzaID,
        originID,
        occupantID,
        myJid,
        senderJid,
        chatJid,
        body,
        timestamp,
        error,
        warning,
        encrypted,
        noStore,
        acked,
        received,
        displayed,
        edited,
        retracted,
        isFileUploadNotification,
        fileDownloading,
        fileUploading,
        fileMetadataID,
        quoting,
        stickerPackID,
        pseudoMessageType,
        const DeepCollectionEquality().hash(_pseudoMessageData),
        const DeepCollectionEquality().hash(_reactionsPreview)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MessageFromDbImplCopyWith<_$MessageFromDbImpl> get copyWith =>
      __$$MessageFromDbImplCopyWithImpl<_$MessageFromDbImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)
        $default, {
    required TResult Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)
        fromDb,
  }) {
    return fromDb(
        id,
        stanzaID,
        originID,
        occupantID,
        myJid,
        senderJid,
        chatJid,
        body,
        timestamp,
        error,
        warning,
        encrypted,
        noStore,
        acked,
        received,
        displayed,
        edited,
        retracted,
        isFileUploadNotification,
        fileDownloading,
        fileUploading,
        fileMetadataID,
        quoting,
        stickerPackID,
        pseudoMessageType,
        pseudoMessageData,
        reactionsPreview);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        $default, {
    TResult? Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        fromDb,
  }) {
    return fromDb?.call(
        id,
        stanzaID,
        originID,
        occupantID,
        myJid,
        senderJid,
        chatJid,
        body,
        timestamp,
        error,
        warning,
        encrypted,
        noStore,
        acked,
        received,
        displayed,
        edited,
        retracted,
        isFileUploadNotification,
        fileDownloading,
        fileUploading,
        fileMetadataID,
        quoting,
        stickerPackID,
        pseudoMessageType,
        pseudoMessageData,
        reactionsPreview);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String stanzaID,
            String myJid,
            String senderJid,
            String chatJid,
            DateTime? timestamp,
            String? id,
            String? originID,
            String? occupantID,
            String? body,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        $default, {
    TResult Function(
            String id,
            String stanzaID,
            String? originID,
            String? occupantID,
            String myJid,
            String senderJid,
            String chatJid,
            String? body,
            DateTime timestamp,
            MessageError error,
            MessageWarning warning,
            bool encrypted,
            bool noStore,
            bool acked,
            bool received,
            bool displayed,
            bool edited,
            bool retracted,
            bool isFileUploadNotification,
            bool fileDownloading,
            bool fileUploading,
            String? fileMetadataID,
            String? quoting,
            String? stickerPackID,
            PseudoMessageType? pseudoMessageType,
            Map<String, dynamic>? pseudoMessageData,
            List<String> reactionsPreview)?
        fromDb,
    required TResult orElse(),
  }) {
    if (fromDb != null) {
      return fromDb(
          id,
          stanzaID,
          originID,
          occupantID,
          myJid,
          senderJid,
          chatJid,
          body,
          timestamp,
          error,
          warning,
          encrypted,
          noStore,
          acked,
          received,
          displayed,
          edited,
          retracted,
          isFileUploadNotification,
          fileDownloading,
          fileUploading,
          fileMetadataID,
          quoting,
          stickerPackID,
          pseudoMessageType,
          pseudoMessageData,
          reactionsPreview);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Message value) $default, {
    required TResult Function(_MessageFromDb value) fromDb,
  }) {
    return fromDb(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Message value)? $default, {
    TResult? Function(_MessageFromDb value)? fromDb,
  }) {
    return fromDb?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Message value)? $default, {
    TResult Function(_MessageFromDb value)? fromDb,
    required TResult orElse(),
  }) {
    if (fromDb != null) {
      return fromDb(this);
    }
    return orElse();
  }
}

abstract class _MessageFromDb extends Message {
  const factory _MessageFromDb(
      {required final String id,
      required final String stanzaID,
      required final String? originID,
      required final String? occupantID,
      required final String myJid,
      required final String senderJid,
      required final String chatJid,
      required final String? body,
      required final DateTime timestamp,
      required final MessageError error,
      required final MessageWarning warning,
      required final bool encrypted,
      required final bool noStore,
      required final bool acked,
      required final bool received,
      required final bool displayed,
      required final bool edited,
      required final bool retracted,
      required final bool isFileUploadNotification,
      required final bool fileDownloading,
      required final bool fileUploading,
      required final String? fileMetadataID,
      required final String? quoting,
      required final String? stickerPackID,
      required final PseudoMessageType? pseudoMessageType,
      required final Map<String, dynamic>? pseudoMessageData,
      final List<String> reactionsPreview}) = _$MessageFromDbImpl;
  const _MessageFromDb._() : super._();

  @override
  String get id;
  @override
  String get stanzaID;
  @override
  String? get originID;
  @override
  String? get occupantID;
  @override
  String get myJid;
  @override
  String get senderJid;
  @override
  String get chatJid;
  @override
  String? get body;
  @override
  DateTime get timestamp;
  @override
  MessageError get error;
  @override
  MessageWarning get warning;
  @override
  bool get encrypted;
  @override
  bool get noStore;
  @override
  bool get acked;
  @override
  bool get received;
  @override
  bool get displayed;
  @override
  bool get edited;
  @override
  bool get retracted;
  @override
  bool get isFileUploadNotification;
  @override
  bool get fileDownloading;
  @override
  bool get fileUploading;
  @override
  String? get fileMetadataID;
  @override
  String? get quoting;
  @override
  String? get stickerPackID;
  @override
  PseudoMessageType? get pseudoMessageType;
  @override
  Map<String, dynamic>? get pseudoMessageData;
  @override
  List<String> get reactionsPreview;
  @override
  @JsonKey(ignore: true)
  _$$MessageFromDbImplCopyWith<_$MessageFromDbImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Reaction {
  String get messageID => throw _privateConstructorUsedError;
  String get myJid => throw _privateConstructorUsedError;
  String get senderJid => throw _privateConstructorUsedError;
  String get emoji => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ReactionCopyWith<Reaction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReactionCopyWith<$Res> {
  factory $ReactionCopyWith(Reaction value, $Res Function(Reaction) then) =
      _$ReactionCopyWithImpl<$Res, Reaction>;
  @useResult
  $Res call({String messageID, String myJid, String senderJid, String emoji});
}

/// @nodoc
class _$ReactionCopyWithImpl<$Res, $Val extends Reaction>
    implements $ReactionCopyWith<$Res> {
  _$ReactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageID = null,
    Object? myJid = null,
    Object? senderJid = null,
    Object? emoji = null,
  }) {
    return _then(_value.copyWith(
      messageID: null == messageID
          ? _value.messageID
          : messageID // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderJid: null == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String,
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ReactionImplCopyWith<$Res>
    implements $ReactionCopyWith<$Res> {
  factory _$$ReactionImplCopyWith(
          _$ReactionImpl value, $Res Function(_$ReactionImpl) then) =
      __$$ReactionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String messageID, String myJid, String senderJid, String emoji});
}

/// @nodoc
class __$$ReactionImplCopyWithImpl<$Res>
    extends _$ReactionCopyWithImpl<$Res, _$ReactionImpl>
    implements _$$ReactionImplCopyWith<$Res> {
  __$$ReactionImplCopyWithImpl(
      _$ReactionImpl _value, $Res Function(_$ReactionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? messageID = null,
    Object? myJid = null,
    Object? senderJid = null,
    Object? emoji = null,
  }) {
    return _then(_$ReactionImpl(
      messageID: null == messageID
          ? _value.messageID
          : messageID // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderJid: null == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String,
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ReactionImpl implements _Reaction {
  const _$ReactionImpl(
      {required this.messageID,
      required this.myJid,
      required this.senderJid,
      required this.emoji});

  @override
  final String messageID;
  @override
  final String myJid;
  @override
  final String senderJid;
  @override
  final String emoji;

  @override
  String toString() {
    return 'Reaction(messageID: $messageID, myJid: $myJid, senderJid: $senderJid, emoji: $emoji)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactionImpl &&
            (identical(other.messageID, messageID) ||
                other.messageID == messageID) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.senderJid, senderJid) ||
                other.senderJid == senderJid) &&
            (identical(other.emoji, emoji) || other.emoji == emoji));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, messageID, myJid, senderJid, emoji);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReactionImplCopyWith<_$ReactionImpl> get copyWith =>
      __$$ReactionImplCopyWithImpl<_$ReactionImpl>(this, _$identity);
}

abstract class _Reaction implements Reaction {
  const factory _Reaction(
      {required final String messageID,
      required final String myJid,
      required final String senderJid,
      required final String emoji}) = _$ReactionImpl;

  @override
  String get messageID;
  @override
  String get myJid;
  @override
  String get senderJid;
  @override
  String get emoji;
  @override
  @JsonKey(ignore: true)
  _$$ReactionImplCopyWith<_$ReactionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Notification {
  int get id => throw _privateConstructorUsedError;
  String? get senderJid => throw _privateConstructorUsedError;
  String get chatJid => throw _privateConstructorUsedError;
  String? get senderName => throw _privateConstructorUsedError;
  String get body => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  String? get avatarPath => throw _privateConstructorUsedError;
  String? get mediaMimeType => throw _privateConstructorUsedError;
  String? get mediaPath => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NotificationCopyWith<Notification> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationCopyWith<$Res> {
  factory $NotificationCopyWith(
          Notification value, $Res Function(Notification) then) =
      _$NotificationCopyWithImpl<$Res, Notification>;
  @useResult
  $Res call(
      {int id,
      String? senderJid,
      String chatJid,
      String? senderName,
      String body,
      DateTime timestamp,
      String? avatarPath,
      String? mediaMimeType,
      String? mediaPath});
}

/// @nodoc
class _$NotificationCopyWithImpl<$Res, $Val extends Notification>
    implements $NotificationCopyWith<$Res> {
  _$NotificationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? senderJid = freezed,
    Object? chatJid = null,
    Object? senderName = freezed,
    Object? body = null,
    Object? timestamp = null,
    Object? avatarPath = freezed,
    Object? mediaMimeType = freezed,
    Object? mediaPath = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      senderJid: freezed == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String?,
      chatJid: null == chatJid
          ? _value.chatJid
          : chatJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderName: freezed == senderName
          ? _value.senderName
          : senderName // ignore: cast_nullable_to_non_nullable
              as String?,
      body: null == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaMimeType: freezed == mediaMimeType
          ? _value.mediaMimeType
          : mediaMimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaPath: freezed == mediaPath
          ? _value.mediaPath
          : mediaPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NotificationImplCopyWith<$Res>
    implements $NotificationCopyWith<$Res> {
  factory _$$NotificationImplCopyWith(
          _$NotificationImpl value, $Res Function(_$NotificationImpl) then) =
      __$$NotificationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      String? senderJid,
      String chatJid,
      String? senderName,
      String body,
      DateTime timestamp,
      String? avatarPath,
      String? mediaMimeType,
      String? mediaPath});
}

/// @nodoc
class __$$NotificationImplCopyWithImpl<$Res>
    extends _$NotificationCopyWithImpl<$Res, _$NotificationImpl>
    implements _$$NotificationImplCopyWith<$Res> {
  __$$NotificationImplCopyWithImpl(
      _$NotificationImpl _value, $Res Function(_$NotificationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? senderJid = freezed,
    Object? chatJid = null,
    Object? senderName = freezed,
    Object? body = null,
    Object? timestamp = null,
    Object? avatarPath = freezed,
    Object? mediaMimeType = freezed,
    Object? mediaPath = freezed,
  }) {
    return _then(_$NotificationImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      senderJid: freezed == senderJid
          ? _value.senderJid
          : senderJid // ignore: cast_nullable_to_non_nullable
              as String?,
      chatJid: null == chatJid
          ? _value.chatJid
          : chatJid // ignore: cast_nullable_to_non_nullable
              as String,
      senderName: freezed == senderName
          ? _value.senderName
          : senderName // ignore: cast_nullable_to_non_nullable
              as String?,
      body: null == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaMimeType: freezed == mediaMimeType
          ? _value.mediaMimeType
          : mediaMimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      mediaPath: freezed == mediaPath
          ? _value.mediaPath
          : mediaPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$NotificationImpl implements _Notification {
  const _$NotificationImpl(
      {required this.id,
      required this.senderJid,
      required this.chatJid,
      required this.senderName,
      required this.body,
      required this.timestamp,
      required this.avatarPath,
      required this.mediaMimeType,
      required this.mediaPath});

  @override
  final int id;
  @override
  final String? senderJid;
  @override
  final String chatJid;
  @override
  final String? senderName;
  @override
  final String body;
  @override
  final DateTime timestamp;
  @override
  final String? avatarPath;
  @override
  final String? mediaMimeType;
  @override
  final String? mediaPath;

  @override
  String toString() {
    return 'Notification(id: $id, senderJid: $senderJid, chatJid: $chatJid, senderName: $senderName, body: $body, timestamp: $timestamp, avatarPath: $avatarPath, mediaMimeType: $mediaMimeType, mediaPath: $mediaPath)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.senderJid, senderJid) ||
                other.senderJid == senderJid) &&
            (identical(other.chatJid, chatJid) || other.chatJid == chatJid) &&
            (identical(other.senderName, senderName) ||
                other.senderName == senderName) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.avatarPath, avatarPath) ||
                other.avatarPath == avatarPath) &&
            (identical(other.mediaMimeType, mediaMimeType) ||
                other.mediaMimeType == mediaMimeType) &&
            (identical(other.mediaPath, mediaPath) ||
                other.mediaPath == mediaPath));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, senderJid, chatJid,
      senderName, body, timestamp, avatarPath, mediaMimeType, mediaPath);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NotificationImplCopyWith<_$NotificationImpl> get copyWith =>
      __$$NotificationImplCopyWithImpl<_$NotificationImpl>(this, _$identity);
}

abstract class _Notification implements Notification {
  const factory _Notification(
      {required final int id,
      required final String? senderJid,
      required final String chatJid,
      required final String? senderName,
      required final String body,
      required final DateTime timestamp,
      required final String? avatarPath,
      required final String? mediaMimeType,
      required final String? mediaPath}) = _$NotificationImpl;

  @override
  int get id;
  @override
  String? get senderJid;
  @override
  String get chatJid;
  @override
  String? get senderName;
  @override
  String get body;
  @override
  DateTime get timestamp;
  @override
  String? get avatarPath;
  @override
  String? get mediaMimeType;
  @override
  String? get mediaPath;
  @override
  @JsonKey(ignore: true)
  _$$NotificationImplCopyWith<_$NotificationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RosterItem _$RosterItemFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'default':
      return _RosterItem.fromJson(json);
    case 'fromDb':
      return _RosterItemFromDb.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'RosterItem',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$RosterItem {
  String get jid => throw _privateConstructorUsedError;
  String get myJid => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  Presence get presence => throw _privateConstructorUsedError;
  Subscription get subscription => throw _privateConstructorUsedError;
  String? get status => throw _privateConstructorUsedError;
  Ask? get ask => throw _privateConstructorUsedError;
  String? get avatarPath => throw _privateConstructorUsedError;
  String? get avatarHash => throw _privateConstructorUsedError;
  String? get contactID => throw _privateConstructorUsedError;
  String? get contactAvatarPath => throw _privateConstructorUsedError;
  String? get contactDisplayName => throw _privateConstructorUsedError;
  List<String> get groups => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)
        $default, {
    required TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)
        fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        $default, {
    TResult? Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        $default, {
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        fromDb,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RosterItem value) $default, {
    required TResult Function(_RosterItemFromDb value) fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RosterItem value)? $default, {
    TResult? Function(_RosterItemFromDb value)? fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RosterItem value)? $default, {
    TResult Function(_RosterItemFromDb value)? fromDb,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RosterItemCopyWith<RosterItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RosterItemCopyWith<$Res> {
  factory $RosterItemCopyWith(
          RosterItem value, $Res Function(RosterItem) then) =
      _$RosterItemCopyWithImpl<$Res, RosterItem>;
  @useResult
  $Res call(
      {String jid,
      String myJid,
      String title,
      Presence presence,
      Subscription subscription,
      String? status,
      Ask? ask,
      String? avatarPath,
      String? avatarHash,
      String? contactID,
      String? contactAvatarPath,
      String? contactDisplayName,
      List<String> groups});
}

/// @nodoc
class _$RosterItemCopyWithImpl<$Res, $Val extends RosterItem>
    implements $RosterItemCopyWith<$Res> {
  _$RosterItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? title = null,
    Object? presence = null,
    Object? subscription = null,
    Object? status = freezed,
    Object? ask = freezed,
    Object? avatarPath = freezed,
    Object? avatarHash = freezed,
    Object? contactID = freezed,
    Object? contactAvatarPath = freezed,
    Object? contactDisplayName = freezed,
    Object? groups = null,
  }) {
    return _then(_value.copyWith(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      presence: null == presence
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as Presence,
      subscription: null == subscription
          ? _value.subscription
          : subscription // ignore: cast_nullable_to_non_nullable
              as Subscription,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      ask: freezed == ask
          ? _value.ask
          : ask // ignore: cast_nullable_to_non_nullable
              as Ask?,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarHash: freezed == avatarHash
          ? _value.avatarHash
          : avatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      contactID: freezed == contactID
          ? _value.contactID
          : contactID // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarPath: freezed == contactAvatarPath
          ? _value.contactAvatarPath
          : contactAvatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      contactDisplayName: freezed == contactDisplayName
          ? _value.contactDisplayName
          : contactDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      groups: null == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RosterItemImplCopyWith<$Res>
    implements $RosterItemCopyWith<$Res> {
  factory _$$RosterItemImplCopyWith(
          _$RosterItemImpl value, $Res Function(_$RosterItemImpl) then) =
      __$$RosterItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String jid,
      String myJid,
      String title,
      Presence presence,
      Subscription subscription,
      String? status,
      Ask? ask,
      String? avatarPath,
      String? avatarHash,
      String? contactID,
      String? contactAvatarPath,
      String? contactDisplayName,
      List<String> groups});
}

/// @nodoc
class __$$RosterItemImplCopyWithImpl<$Res>
    extends _$RosterItemCopyWithImpl<$Res, _$RosterItemImpl>
    implements _$$RosterItemImplCopyWith<$Res> {
  __$$RosterItemImplCopyWithImpl(
      _$RosterItemImpl _value, $Res Function(_$RosterItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? title = null,
    Object? presence = null,
    Object? subscription = null,
    Object? status = freezed,
    Object? ask = freezed,
    Object? avatarPath = freezed,
    Object? avatarHash = freezed,
    Object? contactID = freezed,
    Object? contactAvatarPath = freezed,
    Object? contactDisplayName = freezed,
    Object? groups = null,
  }) {
    return _then(_$RosterItemImpl(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      presence: null == presence
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as Presence,
      subscription: null == subscription
          ? _value.subscription
          : subscription // ignore: cast_nullable_to_non_nullable
              as Subscription,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      ask: freezed == ask
          ? _value.ask
          : ask // ignore: cast_nullable_to_non_nullable
              as Ask?,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarHash: freezed == avatarHash
          ? _value.avatarHash
          : avatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      contactID: freezed == contactID
          ? _value.contactID
          : contactID // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarPath: freezed == contactAvatarPath
          ? _value.contactAvatarPath
          : contactAvatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      contactDisplayName: freezed == contactDisplayName
          ? _value.contactDisplayName
          : contactDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      groups: null == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RosterItemImpl extends _RosterItem {
  const _$RosterItemImpl(
      {required this.jid,
      required this.myJid,
      required this.title,
      required this.presence,
      required this.subscription,
      this.status,
      this.ask,
      this.avatarPath,
      this.avatarHash,
      this.contactID,
      this.contactAvatarPath,
      this.contactDisplayName,
      final List<String> groups = const <String>[],
      final String? $type})
      : _groups = groups,
        $type = $type ?? 'default',
        super._();

  factory _$RosterItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$RosterItemImplFromJson(json);

  @override
  final String jid;
  @override
  final String myJid;
  @override
  final String title;
  @override
  final Presence presence;
  @override
  final Subscription subscription;
  @override
  final String? status;
  @override
  final Ask? ask;
  @override
  final String? avatarPath;
  @override
  final String? avatarHash;
  @override
  final String? contactID;
  @override
  final String? contactAvatarPath;
  @override
  final String? contactDisplayName;
  final List<String> _groups;
  @override
  @JsonKey()
  List<String> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'RosterItem(jid: $jid, myJid: $myJid, title: $title, presence: $presence, subscription: $subscription, status: $status, ask: $ask, avatarPath: $avatarPath, avatarHash: $avatarHash, contactID: $contactID, contactAvatarPath: $contactAvatarPath, contactDisplayName: $contactDisplayName, groups: $groups)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RosterItemImpl &&
            (identical(other.jid, jid) || other.jid == jid) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.presence, presence) ||
                other.presence == presence) &&
            (identical(other.subscription, subscription) ||
                other.subscription == subscription) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.ask, ask) || other.ask == ask) &&
            (identical(other.avatarPath, avatarPath) ||
                other.avatarPath == avatarPath) &&
            (identical(other.avatarHash, avatarHash) ||
                other.avatarHash == avatarHash) &&
            (identical(other.contactID, contactID) ||
                other.contactID == contactID) &&
            (identical(other.contactAvatarPath, contactAvatarPath) ||
                other.contactAvatarPath == contactAvatarPath) &&
            (identical(other.contactDisplayName, contactDisplayName) ||
                other.contactDisplayName == contactDisplayName) &&
            const DeepCollectionEquality().equals(other._groups, _groups));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      jid,
      myJid,
      title,
      presence,
      subscription,
      status,
      ask,
      avatarPath,
      avatarHash,
      contactID,
      contactAvatarPath,
      contactDisplayName,
      const DeepCollectionEquality().hash(_groups));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RosterItemImplCopyWith<_$RosterItemImpl> get copyWith =>
      __$$RosterItemImplCopyWithImpl<_$RosterItemImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)
        $default, {
    required TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)
        fromDb,
  }) {
    return $default(
        jid,
        myJid,
        title,
        presence,
        subscription,
        status,
        ask,
        avatarPath,
        avatarHash,
        contactID,
        contactAvatarPath,
        contactDisplayName,
        groups);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        $default, {
    TResult? Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        fromDb,
  }) {
    return $default?.call(
        jid,
        myJid,
        title,
        presence,
        subscription,
        status,
        ask,
        avatarPath,
        avatarHash,
        contactID,
        contactAvatarPath,
        contactDisplayName,
        groups);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        $default, {
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        fromDb,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(
          jid,
          myJid,
          title,
          presence,
          subscription,
          status,
          ask,
          avatarPath,
          avatarHash,
          contactID,
          contactAvatarPath,
          contactDisplayName,
          groups);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RosterItem value) $default, {
    required TResult Function(_RosterItemFromDb value) fromDb,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RosterItem value)? $default, {
    TResult? Function(_RosterItemFromDb value)? fromDb,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RosterItem value)? $default, {
    TResult Function(_RosterItemFromDb value)? fromDb,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RosterItemImplToJson(
      this,
    );
  }
}

abstract class _RosterItem extends RosterItem {
  const factory _RosterItem(
      {required final String jid,
      required final String myJid,
      required final String title,
      required final Presence presence,
      required final Subscription subscription,
      final String? status,
      final Ask? ask,
      final String? avatarPath,
      final String? avatarHash,
      final String? contactID,
      final String? contactAvatarPath,
      final String? contactDisplayName,
      final List<String> groups}) = _$RosterItemImpl;
  const _RosterItem._() : super._();

  factory _RosterItem.fromJson(Map<String, dynamic> json) =
      _$RosterItemImpl.fromJson;

  @override
  String get jid;
  @override
  String get myJid;
  @override
  String get title;
  @override
  Presence get presence;
  @override
  Subscription get subscription;
  @override
  String? get status;
  @override
  Ask? get ask;
  @override
  String? get avatarPath;
  @override
  String? get avatarHash;
  @override
  String? get contactID;
  @override
  String? get contactAvatarPath;
  @override
  String? get contactDisplayName;
  @override
  List<String> get groups;
  @override
  @JsonKey(ignore: true)
  _$$RosterItemImplCopyWith<_$RosterItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RosterItemFromDbImplCopyWith<$Res>
    implements $RosterItemCopyWith<$Res> {
  factory _$$RosterItemFromDbImplCopyWith(_$RosterItemFromDbImpl value,
          $Res Function(_$RosterItemFromDbImpl) then) =
      __$$RosterItemFromDbImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String jid,
      String myJid,
      String title,
      Presence presence,
      String? status,
      String? avatarPath,
      String? avatarHash,
      Subscription subscription,
      Ask? ask,
      String? contactID,
      String? contactAvatarPath,
      String? contactDisplayName,
      List<String> groups});
}

/// @nodoc
class __$$RosterItemFromDbImplCopyWithImpl<$Res>
    extends _$RosterItemCopyWithImpl<$Res, _$RosterItemFromDbImpl>
    implements _$$RosterItemFromDbImplCopyWith<$Res> {
  __$$RosterItemFromDbImplCopyWithImpl(_$RosterItemFromDbImpl _value,
      $Res Function(_$RosterItemFromDbImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? title = null,
    Object? presence = null,
    Object? status = freezed,
    Object? avatarPath = freezed,
    Object? avatarHash = freezed,
    Object? subscription = null,
    Object? ask = freezed,
    Object? contactID = freezed,
    Object? contactAvatarPath = freezed,
    Object? contactDisplayName = freezed,
    Object? groups = null,
  }) {
    return _then(_$RosterItemFromDbImpl(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      presence: null == presence
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as Presence,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarHash: freezed == avatarHash
          ? _value.avatarHash
          : avatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      subscription: null == subscription
          ? _value.subscription
          : subscription // ignore: cast_nullable_to_non_nullable
              as Subscription,
      ask: freezed == ask
          ? _value.ask
          : ask // ignore: cast_nullable_to_non_nullable
              as Ask?,
      contactID: freezed == contactID
          ? _value.contactID
          : contactID // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarPath: freezed == contactAvatarPath
          ? _value.contactAvatarPath
          : contactAvatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      contactDisplayName: freezed == contactDisplayName
          ? _value.contactDisplayName
          : contactDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      groups: null == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RosterItemFromDbImpl extends _RosterItemFromDb {
  const _$RosterItemFromDbImpl(
      {required this.jid,
      required this.myJid,
      required this.title,
      required this.presence,
      required this.status,
      required this.avatarPath,
      required this.avatarHash,
      required this.subscription,
      required this.ask,
      required this.contactID,
      required this.contactAvatarPath,
      required this.contactDisplayName,
      final List<String> groups = const <String>[],
      final String? $type})
      : _groups = groups,
        $type = $type ?? 'fromDb',
        super._();

  factory _$RosterItemFromDbImpl.fromJson(Map<String, dynamic> json) =>
      _$$RosterItemFromDbImplFromJson(json);

  @override
  final String jid;
  @override
  final String myJid;
  @override
  final String title;
  @override
  final Presence presence;
  @override
  final String? status;
  @override
  final String? avatarPath;
  @override
  final String? avatarHash;
  @override
  final Subscription subscription;
  @override
  final Ask? ask;
  @override
  final String? contactID;
  @override
  final String? contactAvatarPath;
  @override
  final String? contactDisplayName;
  final List<String> _groups;
  @override
  @JsonKey()
  List<String> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'RosterItem.fromDb(jid: $jid, myJid: $myJid, title: $title, presence: $presence, status: $status, avatarPath: $avatarPath, avatarHash: $avatarHash, subscription: $subscription, ask: $ask, contactID: $contactID, contactAvatarPath: $contactAvatarPath, contactDisplayName: $contactDisplayName, groups: $groups)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RosterItemFromDbImpl &&
            (identical(other.jid, jid) || other.jid == jid) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.presence, presence) ||
                other.presence == presence) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.avatarPath, avatarPath) ||
                other.avatarPath == avatarPath) &&
            (identical(other.avatarHash, avatarHash) ||
                other.avatarHash == avatarHash) &&
            (identical(other.subscription, subscription) ||
                other.subscription == subscription) &&
            (identical(other.ask, ask) || other.ask == ask) &&
            (identical(other.contactID, contactID) ||
                other.contactID == contactID) &&
            (identical(other.contactAvatarPath, contactAvatarPath) ||
                other.contactAvatarPath == contactAvatarPath) &&
            (identical(other.contactDisplayName, contactDisplayName) ||
                other.contactDisplayName == contactDisplayName) &&
            const DeepCollectionEquality().equals(other._groups, _groups));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      jid,
      myJid,
      title,
      presence,
      status,
      avatarPath,
      avatarHash,
      subscription,
      ask,
      contactID,
      contactAvatarPath,
      contactDisplayName,
      const DeepCollectionEquality().hash(_groups));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RosterItemFromDbImplCopyWith<_$RosterItemFromDbImpl> get copyWith =>
      __$$RosterItemFromDbImplCopyWithImpl<_$RosterItemFromDbImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)
        $default, {
    required TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)
        fromDb,
  }) {
    return fromDb(
        jid,
        myJid,
        title,
        presence,
        status,
        avatarPath,
        avatarHash,
        subscription,
        ask,
        contactID,
        contactAvatarPath,
        contactDisplayName,
        groups);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        $default, {
    TResult? Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        fromDb,
  }) {
    return fromDb?.call(
        jid,
        myJid,
        title,
        presence,
        status,
        avatarPath,
        avatarHash,
        subscription,
        ask,
        contactID,
        contactAvatarPath,
        contactDisplayName,
        groups);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            Subscription subscription,
            String? status,
            Ask? ask,
            String? avatarPath,
            String? avatarHash,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        $default, {
    TResult Function(
            String jid,
            String myJid,
            String title,
            Presence presence,
            String? status,
            String? avatarPath,
            String? avatarHash,
            Subscription subscription,
            Ask? ask,
            String? contactID,
            String? contactAvatarPath,
            String? contactDisplayName,
            List<String> groups)?
        fromDb,
    required TResult orElse(),
  }) {
    if (fromDb != null) {
      return fromDb(
          jid,
          myJid,
          title,
          presence,
          status,
          avatarPath,
          avatarHash,
          subscription,
          ask,
          contactID,
          contactAvatarPath,
          contactDisplayName,
          groups);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_RosterItem value) $default, {
    required TResult Function(_RosterItemFromDb value) fromDb,
  }) {
    return fromDb(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_RosterItem value)? $default, {
    TResult? Function(_RosterItemFromDb value)? fromDb,
  }) {
    return fromDb?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_RosterItem value)? $default, {
    TResult Function(_RosterItemFromDb value)? fromDb,
    required TResult orElse(),
  }) {
    if (fromDb != null) {
      return fromDb(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RosterItemFromDbImplToJson(
      this,
    );
  }
}

abstract class _RosterItemFromDb extends RosterItem {
  const factory _RosterItemFromDb(
      {required final String jid,
      required final String myJid,
      required final String title,
      required final Presence presence,
      required final String? status,
      required final String? avatarPath,
      required final String? avatarHash,
      required final Subscription subscription,
      required final Ask? ask,
      required final String? contactID,
      required final String? contactAvatarPath,
      required final String? contactDisplayName,
      final List<String> groups}) = _$RosterItemFromDbImpl;
  const _RosterItemFromDb._() : super._();

  factory _RosterItemFromDb.fromJson(Map<String, dynamic> json) =
      _$RosterItemFromDbImpl.fromJson;

  @override
  String get jid;
  @override
  String get myJid;
  @override
  String get title;
  @override
  Presence get presence;
  @override
  String? get status;
  @override
  String? get avatarPath;
  @override
  String? get avatarHash;
  @override
  Subscription get subscription;
  @override
  Ask? get ask;
  @override
  String? get contactID;
  @override
  String? get contactAvatarPath;
  @override
  String? get contactDisplayName;
  @override
  List<String> get groups;
  @override
  @JsonKey(ignore: true)
  _$$RosterItemFromDbImplCopyWith<_$RosterItemFromDbImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Invite {
  String get jid => throw _privateConstructorUsedError;
  String get myJid => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $InviteCopyWith<Invite> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InviteCopyWith<$Res> {
  factory $InviteCopyWith(Invite value, $Res Function(Invite) then) =
      _$InviteCopyWithImpl<$Res, Invite>;
  @useResult
  $Res call({String jid, String myJid, String title});
}

/// @nodoc
class _$InviteCopyWithImpl<$Res, $Val extends Invite>
    implements $InviteCopyWith<$Res> {
  _$InviteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? title = null,
  }) {
    return _then(_value.copyWith(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InviteImplCopyWith<$Res> implements $InviteCopyWith<$Res> {
  factory _$$InviteImplCopyWith(
          _$InviteImpl value, $Res Function(_$InviteImpl) then) =
      __$$InviteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String jid, String myJid, String title});
}

/// @nodoc
class __$$InviteImplCopyWithImpl<$Res>
    extends _$InviteCopyWithImpl<$Res, _$InviteImpl>
    implements _$$InviteImplCopyWith<$Res> {
  __$$InviteImplCopyWithImpl(
      _$InviteImpl _value, $Res Function(_$InviteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? title = null,
  }) {
    return _then(_$InviteImpl(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InviteImpl extends _Invite {
  const _$InviteImpl(
      {required this.jid, required this.myJid, required this.title})
      : super._();

  @override
  final String jid;
  @override
  final String myJid;
  @override
  final String title;

  @override
  String toString() {
    return 'Invite(jid: $jid, myJid: $myJid, title: $title)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InviteImpl &&
            (identical(other.jid, jid) || other.jid == jid) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.title, title) || other.title == title));
  }

  @override
  int get hashCode => Object.hash(runtimeType, jid, myJid, title);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InviteImplCopyWith<_$InviteImpl> get copyWith =>
      __$$InviteImplCopyWithImpl<_$InviteImpl>(this, _$identity);
}

abstract class _Invite extends Invite {
  const factory _Invite(
      {required final String jid,
      required final String myJid,
      required final String title}) = _$InviteImpl;
  const _Invite._() : super._();

  @override
  String get jid;
  @override
  String get myJid;
  @override
  String get title;
  @override
  @JsonKey(ignore: true)
  _$$InviteImplCopyWith<_$InviteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Chat {
  String get jid => throw _privateConstructorUsedError;
  String get myJid => throw _privateConstructorUsedError;
  String get myNickname => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  ChatType get type => throw _privateConstructorUsedError;
  DateTime get lastChangeTimestamp => throw _privateConstructorUsedError;
  String? get avatarPath => throw _privateConstructorUsedError;
  String? get avatarHash => throw _privateConstructorUsedError;
  String? get lastMessage => throw _privateConstructorUsedError;
  int get unreadCount => throw _privateConstructorUsedError;
  bool get open => throw _privateConstructorUsedError;
  bool get muted => throw _privateConstructorUsedError;
  bool get encrypted => throw _privateConstructorUsedError;
  bool get favourited => throw _privateConstructorUsedError;
  String? get contactID => throw _privateConstructorUsedError;
  String? get contactDisplayName => throw _privateConstructorUsedError;
  String? get contactAvatarPath => throw _privateConstructorUsedError;
  String? get contactAvatarHash => throw _privateConstructorUsedError;
  mox.ChatState? get chatState => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)
        $default, {
    required TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)
        fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        $default, {
    TResult? Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        $default, {
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        fromDb,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Chat value) $default, {
    required TResult Function(_ChatFromDb value) fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Chat value)? $default, {
    TResult? Function(_ChatFromDb value)? fromDb,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Chat value)? $default, {
    TResult Function(_ChatFromDb value)? fromDb,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChatCopyWith<Chat> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatCopyWith<$Res> {
  factory $ChatCopyWith(Chat value, $Res Function(Chat) then) =
      _$ChatCopyWithImpl<$Res, Chat>;
  @useResult
  $Res call(
      {String jid,
      String myJid,
      String myNickname,
      String title,
      ChatType type,
      DateTime lastChangeTimestamp,
      String? avatarPath,
      String? avatarHash,
      String? lastMessage,
      int unreadCount,
      bool open,
      bool muted,
      bool encrypted,
      bool favourited,
      String? contactID,
      String? contactDisplayName,
      String? contactAvatarPath,
      String? contactAvatarHash,
      mox.ChatState? chatState});
}

/// @nodoc
class _$ChatCopyWithImpl<$Res, $Val extends Chat>
    implements $ChatCopyWith<$Res> {
  _$ChatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? myNickname = null,
    Object? title = null,
    Object? type = null,
    Object? lastChangeTimestamp = null,
    Object? avatarPath = freezed,
    Object? avatarHash = freezed,
    Object? lastMessage = freezed,
    Object? unreadCount = null,
    Object? open = null,
    Object? muted = null,
    Object? encrypted = null,
    Object? favourited = null,
    Object? contactID = freezed,
    Object? contactDisplayName = freezed,
    Object? contactAvatarPath = freezed,
    Object? contactAvatarHash = freezed,
    Object? chatState = freezed,
  }) {
    return _then(_value.copyWith(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      myNickname: null == myNickname
          ? _value.myNickname
          : myNickname // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatType,
      lastChangeTimestamp: null == lastChangeTimestamp
          ? _value.lastChangeTimestamp
          : lastChangeTimestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarHash: freezed == avatarHash
          ? _value.avatarHash
          : avatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      lastMessage: freezed == lastMessage
          ? _value.lastMessage
          : lastMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      unreadCount: null == unreadCount
          ? _value.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int,
      open: null == open
          ? _value.open
          : open // ignore: cast_nullable_to_non_nullable
              as bool,
      muted: null == muted
          ? _value.muted
          : muted // ignore: cast_nullable_to_non_nullable
              as bool,
      encrypted: null == encrypted
          ? _value.encrypted
          : encrypted // ignore: cast_nullable_to_non_nullable
              as bool,
      favourited: null == favourited
          ? _value.favourited
          : favourited // ignore: cast_nullable_to_non_nullable
              as bool,
      contactID: freezed == contactID
          ? _value.contactID
          : contactID // ignore: cast_nullable_to_non_nullable
              as String?,
      contactDisplayName: freezed == contactDisplayName
          ? _value.contactDisplayName
          : contactDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarPath: freezed == contactAvatarPath
          ? _value.contactAvatarPath
          : contactAvatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarHash: freezed == contactAvatarHash
          ? _value.contactAvatarHash
          : contactAvatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      chatState: freezed == chatState
          ? _value.chatState
          : chatState // ignore: cast_nullable_to_non_nullable
              as mox.ChatState?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChatImplCopyWith<$Res> implements $ChatCopyWith<$Res> {
  factory _$$ChatImplCopyWith(
          _$ChatImpl value, $Res Function(_$ChatImpl) then) =
      __$$ChatImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String jid,
      String myJid,
      String myNickname,
      String title,
      ChatType type,
      DateTime lastChangeTimestamp,
      String? avatarPath,
      String? avatarHash,
      String? lastMessage,
      int unreadCount,
      bool open,
      bool muted,
      bool encrypted,
      bool favourited,
      String? contactID,
      String? contactDisplayName,
      String? contactAvatarPath,
      String? contactAvatarHash,
      mox.ChatState? chatState});
}

/// @nodoc
class __$$ChatImplCopyWithImpl<$Res>
    extends _$ChatCopyWithImpl<$Res, _$ChatImpl>
    implements _$$ChatImplCopyWith<$Res> {
  __$$ChatImplCopyWithImpl(_$ChatImpl _value, $Res Function(_$ChatImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? myNickname = null,
    Object? title = null,
    Object? type = null,
    Object? lastChangeTimestamp = null,
    Object? avatarPath = freezed,
    Object? avatarHash = freezed,
    Object? lastMessage = freezed,
    Object? unreadCount = null,
    Object? open = null,
    Object? muted = null,
    Object? encrypted = null,
    Object? favourited = null,
    Object? contactID = freezed,
    Object? contactDisplayName = freezed,
    Object? contactAvatarPath = freezed,
    Object? contactAvatarHash = freezed,
    Object? chatState = freezed,
  }) {
    return _then(_$ChatImpl(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      myNickname: null == myNickname
          ? _value.myNickname
          : myNickname // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatType,
      lastChangeTimestamp: null == lastChangeTimestamp
          ? _value.lastChangeTimestamp
          : lastChangeTimestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarHash: freezed == avatarHash
          ? _value.avatarHash
          : avatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      lastMessage: freezed == lastMessage
          ? _value.lastMessage
          : lastMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      unreadCount: null == unreadCount
          ? _value.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int,
      open: null == open
          ? _value.open
          : open // ignore: cast_nullable_to_non_nullable
              as bool,
      muted: null == muted
          ? _value.muted
          : muted // ignore: cast_nullable_to_non_nullable
              as bool,
      encrypted: null == encrypted
          ? _value.encrypted
          : encrypted // ignore: cast_nullable_to_non_nullable
              as bool,
      favourited: null == favourited
          ? _value.favourited
          : favourited // ignore: cast_nullable_to_non_nullable
              as bool,
      contactID: freezed == contactID
          ? _value.contactID
          : contactID // ignore: cast_nullable_to_non_nullable
              as String?,
      contactDisplayName: freezed == contactDisplayName
          ? _value.contactDisplayName
          : contactDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarPath: freezed == contactAvatarPath
          ? _value.contactAvatarPath
          : contactAvatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarHash: freezed == contactAvatarHash
          ? _value.contactAvatarHash
          : contactAvatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      chatState: freezed == chatState
          ? _value.chatState
          : chatState // ignore: cast_nullable_to_non_nullable
              as mox.ChatState?,
    ));
  }
}

/// @nodoc

class _$ChatImpl extends _Chat {
  const _$ChatImpl(
      {required this.jid,
      required this.myJid,
      required this.myNickname,
      required this.title,
      required this.type,
      required this.lastChangeTimestamp,
      this.avatarPath,
      this.avatarHash,
      this.lastMessage,
      this.unreadCount = 0,
      this.open = false,
      this.muted = false,
      this.encrypted = false,
      this.favourited = false,
      this.contactID,
      this.contactDisplayName,
      this.contactAvatarPath,
      this.contactAvatarHash,
      this.chatState})
      : super._();

  @override
  final String jid;
  @override
  final String myJid;
  @override
  final String myNickname;
  @override
  final String title;
  @override
  final ChatType type;
  @override
  final DateTime lastChangeTimestamp;
  @override
  final String? avatarPath;
  @override
  final String? avatarHash;
  @override
  final String? lastMessage;
  @override
  @JsonKey()
  final int unreadCount;
  @override
  @JsonKey()
  final bool open;
  @override
  @JsonKey()
  final bool muted;
  @override
  @JsonKey()
  final bool encrypted;
  @override
  @JsonKey()
  final bool favourited;
  @override
  final String? contactID;
  @override
  final String? contactDisplayName;
  @override
  final String? contactAvatarPath;
  @override
  final String? contactAvatarHash;
  @override
  final mox.ChatState? chatState;

  @override
  String toString() {
    return 'Chat(jid: $jid, myJid: $myJid, myNickname: $myNickname, title: $title, type: $type, lastChangeTimestamp: $lastChangeTimestamp, avatarPath: $avatarPath, avatarHash: $avatarHash, lastMessage: $lastMessage, unreadCount: $unreadCount, open: $open, muted: $muted, encrypted: $encrypted, favourited: $favourited, contactID: $contactID, contactDisplayName: $contactDisplayName, contactAvatarPath: $contactAvatarPath, contactAvatarHash: $contactAvatarHash, chatState: $chatState)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatImpl &&
            (identical(other.jid, jid) || other.jid == jid) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.myNickname, myNickname) ||
                other.myNickname == myNickname) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.lastChangeTimestamp, lastChangeTimestamp) ||
                other.lastChangeTimestamp == lastChangeTimestamp) &&
            (identical(other.avatarPath, avatarPath) ||
                other.avatarPath == avatarPath) &&
            (identical(other.avatarHash, avatarHash) ||
                other.avatarHash == avatarHash) &&
            (identical(other.lastMessage, lastMessage) ||
                other.lastMessage == lastMessage) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.open, open) || other.open == open) &&
            (identical(other.muted, muted) || other.muted == muted) &&
            (identical(other.encrypted, encrypted) ||
                other.encrypted == encrypted) &&
            (identical(other.favourited, favourited) ||
                other.favourited == favourited) &&
            (identical(other.contactID, contactID) ||
                other.contactID == contactID) &&
            (identical(other.contactDisplayName, contactDisplayName) ||
                other.contactDisplayName == contactDisplayName) &&
            (identical(other.contactAvatarPath, contactAvatarPath) ||
                other.contactAvatarPath == contactAvatarPath) &&
            (identical(other.contactAvatarHash, contactAvatarHash) ||
                other.contactAvatarHash == contactAvatarHash) &&
            (identical(other.chatState, chatState) ||
                other.chatState == chatState));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        jid,
        myJid,
        myNickname,
        title,
        type,
        lastChangeTimestamp,
        avatarPath,
        avatarHash,
        lastMessage,
        unreadCount,
        open,
        muted,
        encrypted,
        favourited,
        contactID,
        contactDisplayName,
        contactAvatarPath,
        contactAvatarHash,
        chatState
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatImplCopyWith<_$ChatImpl> get copyWith =>
      __$$ChatImplCopyWithImpl<_$ChatImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)
        $default, {
    required TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)
        fromDb,
  }) {
    return $default(
        jid,
        myJid,
        myNickname,
        title,
        type,
        lastChangeTimestamp,
        avatarPath,
        avatarHash,
        lastMessage,
        unreadCount,
        open,
        muted,
        encrypted,
        favourited,
        contactID,
        contactDisplayName,
        contactAvatarPath,
        contactAvatarHash,
        chatState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        $default, {
    TResult? Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        fromDb,
  }) {
    return $default?.call(
        jid,
        myJid,
        myNickname,
        title,
        type,
        lastChangeTimestamp,
        avatarPath,
        avatarHash,
        lastMessage,
        unreadCount,
        open,
        muted,
        encrypted,
        favourited,
        contactID,
        contactDisplayName,
        contactAvatarPath,
        contactAvatarHash,
        chatState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        $default, {
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        fromDb,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(
          jid,
          myJid,
          myNickname,
          title,
          type,
          lastChangeTimestamp,
          avatarPath,
          avatarHash,
          lastMessage,
          unreadCount,
          open,
          muted,
          encrypted,
          favourited,
          contactID,
          contactDisplayName,
          contactAvatarPath,
          contactAvatarHash,
          chatState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Chat value) $default, {
    required TResult Function(_ChatFromDb value) fromDb,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Chat value)? $default, {
    TResult? Function(_ChatFromDb value)? fromDb,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Chat value)? $default, {
    TResult Function(_ChatFromDb value)? fromDb,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _Chat extends Chat {
  const factory _Chat(
      {required final String jid,
      required final String myJid,
      required final String myNickname,
      required final String title,
      required final ChatType type,
      required final DateTime lastChangeTimestamp,
      final String? avatarPath,
      final String? avatarHash,
      final String? lastMessage,
      final int unreadCount,
      final bool open,
      final bool muted,
      final bool encrypted,
      final bool favourited,
      final String? contactID,
      final String? contactDisplayName,
      final String? contactAvatarPath,
      final String? contactAvatarHash,
      final mox.ChatState? chatState}) = _$ChatImpl;
  const _Chat._() : super._();

  @override
  String get jid;
  @override
  String get myJid;
  @override
  String get myNickname;
  @override
  String get title;
  @override
  ChatType get type;
  @override
  DateTime get lastChangeTimestamp;
  @override
  String? get avatarPath;
  @override
  String? get avatarHash;
  @override
  String? get lastMessage;
  @override
  int get unreadCount;
  @override
  bool get open;
  @override
  bool get muted;
  @override
  bool get encrypted;
  @override
  bool get favourited;
  @override
  String? get contactID;
  @override
  String? get contactDisplayName;
  @override
  String? get contactAvatarPath;
  @override
  String? get contactAvatarHash;
  @override
  mox.ChatState? get chatState;
  @override
  @JsonKey(ignore: true)
  _$$ChatImplCopyWith<_$ChatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChatFromDbImplCopyWith<$Res> implements $ChatCopyWith<$Res> {
  factory _$$ChatFromDbImplCopyWith(
          _$ChatFromDbImpl value, $Res Function(_$ChatFromDbImpl) then) =
      __$$ChatFromDbImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String jid,
      String myJid,
      String myNickname,
      String title,
      ChatType type,
      String? avatarPath,
      String? avatarHash,
      String? lastMessage,
      DateTime lastChangeTimestamp,
      int unreadCount,
      bool open,
      bool muted,
      bool encrypted,
      bool favourited,
      String? contactID,
      String? contactDisplayName,
      String? contactAvatarPath,
      String? contactAvatarHash,
      mox.ChatState? chatState});
}

/// @nodoc
class __$$ChatFromDbImplCopyWithImpl<$Res>
    extends _$ChatCopyWithImpl<$Res, _$ChatFromDbImpl>
    implements _$$ChatFromDbImplCopyWith<$Res> {
  __$$ChatFromDbImplCopyWithImpl(
      _$ChatFromDbImpl _value, $Res Function(_$ChatFromDbImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? jid = null,
    Object? myJid = null,
    Object? myNickname = null,
    Object? title = null,
    Object? type = null,
    Object? avatarPath = freezed,
    Object? avatarHash = freezed,
    Object? lastMessage = freezed,
    Object? lastChangeTimestamp = null,
    Object? unreadCount = null,
    Object? open = null,
    Object? muted = null,
    Object? encrypted = null,
    Object? favourited = null,
    Object? contactID = freezed,
    Object? contactDisplayName = freezed,
    Object? contactAvatarPath = freezed,
    Object? contactAvatarHash = freezed,
    Object? chatState = freezed,
  }) {
    return _then(_$ChatFromDbImpl(
      jid: null == jid
          ? _value.jid
          : jid // ignore: cast_nullable_to_non_nullable
              as String,
      myJid: null == myJid
          ? _value.myJid
          : myJid // ignore: cast_nullable_to_non_nullable
              as String,
      myNickname: null == myNickname
          ? _value.myNickname
          : myNickname // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChatType,
      avatarPath: freezed == avatarPath
          ? _value.avatarPath
          : avatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      avatarHash: freezed == avatarHash
          ? _value.avatarHash
          : avatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      lastMessage: freezed == lastMessage
          ? _value.lastMessage
          : lastMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      lastChangeTimestamp: null == lastChangeTimestamp
          ? _value.lastChangeTimestamp
          : lastChangeTimestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      unreadCount: null == unreadCount
          ? _value.unreadCount
          : unreadCount // ignore: cast_nullable_to_non_nullable
              as int,
      open: null == open
          ? _value.open
          : open // ignore: cast_nullable_to_non_nullable
              as bool,
      muted: null == muted
          ? _value.muted
          : muted // ignore: cast_nullable_to_non_nullable
              as bool,
      encrypted: null == encrypted
          ? _value.encrypted
          : encrypted // ignore: cast_nullable_to_non_nullable
              as bool,
      favourited: null == favourited
          ? _value.favourited
          : favourited // ignore: cast_nullable_to_non_nullable
              as bool,
      contactID: freezed == contactID
          ? _value.contactID
          : contactID // ignore: cast_nullable_to_non_nullable
              as String?,
      contactDisplayName: freezed == contactDisplayName
          ? _value.contactDisplayName
          : contactDisplayName // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarPath: freezed == contactAvatarPath
          ? _value.contactAvatarPath
          : contactAvatarPath // ignore: cast_nullable_to_non_nullable
              as String?,
      contactAvatarHash: freezed == contactAvatarHash
          ? _value.contactAvatarHash
          : contactAvatarHash // ignore: cast_nullable_to_non_nullable
              as String?,
      chatState: freezed == chatState
          ? _value.chatState
          : chatState // ignore: cast_nullable_to_non_nullable
              as mox.ChatState?,
    ));
  }
}

/// @nodoc

class _$ChatFromDbImpl extends _ChatFromDb {
  const _$ChatFromDbImpl(
      {required this.jid,
      required this.myJid,
      required this.myNickname,
      required this.title,
      required this.type,
      required this.avatarPath,
      required this.avatarHash,
      required this.lastMessage,
      required this.lastChangeTimestamp,
      required this.unreadCount,
      required this.open,
      required this.muted,
      required this.encrypted,
      required this.favourited,
      required this.contactID,
      required this.contactDisplayName,
      required this.contactAvatarPath,
      required this.contactAvatarHash,
      this.chatState})
      : super._();

  @override
  final String jid;
  @override
  final String myJid;
  @override
  final String myNickname;
  @override
  final String title;
  @override
  final ChatType type;
  @override
  final String? avatarPath;
  @override
  final String? avatarHash;
  @override
  final String? lastMessage;
  @override
  final DateTime lastChangeTimestamp;
  @override
  final int unreadCount;
  @override
  final bool open;
  @override
  final bool muted;
  @override
  final bool encrypted;
  @override
  final bool favourited;
  @override
  final String? contactID;
  @override
  final String? contactDisplayName;
  @override
  final String? contactAvatarPath;
  @override
  final String? contactAvatarHash;
  @override
  final mox.ChatState? chatState;

  @override
  String toString() {
    return 'Chat.fromDb(jid: $jid, myJid: $myJid, myNickname: $myNickname, title: $title, type: $type, avatarPath: $avatarPath, avatarHash: $avatarHash, lastMessage: $lastMessage, lastChangeTimestamp: $lastChangeTimestamp, unreadCount: $unreadCount, open: $open, muted: $muted, encrypted: $encrypted, favourited: $favourited, contactID: $contactID, contactDisplayName: $contactDisplayName, contactAvatarPath: $contactAvatarPath, contactAvatarHash: $contactAvatarHash, chatState: $chatState)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChatFromDbImpl &&
            (identical(other.jid, jid) || other.jid == jid) &&
            (identical(other.myJid, myJid) || other.myJid == myJid) &&
            (identical(other.myNickname, myNickname) ||
                other.myNickname == myNickname) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.avatarPath, avatarPath) ||
                other.avatarPath == avatarPath) &&
            (identical(other.avatarHash, avatarHash) ||
                other.avatarHash == avatarHash) &&
            (identical(other.lastMessage, lastMessage) ||
                other.lastMessage == lastMessage) &&
            (identical(other.lastChangeTimestamp, lastChangeTimestamp) ||
                other.lastChangeTimestamp == lastChangeTimestamp) &&
            (identical(other.unreadCount, unreadCount) ||
                other.unreadCount == unreadCount) &&
            (identical(other.open, open) || other.open == open) &&
            (identical(other.muted, muted) || other.muted == muted) &&
            (identical(other.encrypted, encrypted) ||
                other.encrypted == encrypted) &&
            (identical(other.favourited, favourited) ||
                other.favourited == favourited) &&
            (identical(other.contactID, contactID) ||
                other.contactID == contactID) &&
            (identical(other.contactDisplayName, contactDisplayName) ||
                other.contactDisplayName == contactDisplayName) &&
            (identical(other.contactAvatarPath, contactAvatarPath) ||
                other.contactAvatarPath == contactAvatarPath) &&
            (identical(other.contactAvatarHash, contactAvatarHash) ||
                other.contactAvatarHash == contactAvatarHash) &&
            (identical(other.chatState, chatState) ||
                other.chatState == chatState));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        jid,
        myJid,
        myNickname,
        title,
        type,
        avatarPath,
        avatarHash,
        lastMessage,
        lastChangeTimestamp,
        unreadCount,
        open,
        muted,
        encrypted,
        favourited,
        contactID,
        contactDisplayName,
        contactAvatarPath,
        contactAvatarHash,
        chatState
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChatFromDbImplCopyWith<_$ChatFromDbImpl> get copyWith =>
      __$$ChatFromDbImplCopyWithImpl<_$ChatFromDbImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)
        $default, {
    required TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)
        fromDb,
  }) {
    return fromDb(
        jid,
        myJid,
        myNickname,
        title,
        type,
        avatarPath,
        avatarHash,
        lastMessage,
        lastChangeTimestamp,
        unreadCount,
        open,
        muted,
        encrypted,
        favourited,
        contactID,
        contactDisplayName,
        contactAvatarPath,
        contactAvatarHash,
        chatState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        $default, {
    TResult? Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        fromDb,
  }) {
    return fromDb?.call(
        jid,
        myJid,
        myNickname,
        title,
        type,
        avatarPath,
        avatarHash,
        lastMessage,
        lastChangeTimestamp,
        unreadCount,
        open,
        muted,
        encrypted,
        favourited,
        contactID,
        contactDisplayName,
        contactAvatarPath,
        contactAvatarHash,
        chatState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            DateTime lastChangeTimestamp,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        $default, {
    TResult Function(
            String jid,
            String myJid,
            String myNickname,
            String title,
            ChatType type,
            String? avatarPath,
            String? avatarHash,
            String? lastMessage,
            DateTime lastChangeTimestamp,
            int unreadCount,
            bool open,
            bool muted,
            bool encrypted,
            bool favourited,
            String? contactID,
            String? contactDisplayName,
            String? contactAvatarPath,
            String? contactAvatarHash,
            mox.ChatState? chatState)?
        fromDb,
    required TResult orElse(),
  }) {
    if (fromDb != null) {
      return fromDb(
          jid,
          myJid,
          myNickname,
          title,
          type,
          avatarPath,
          avatarHash,
          lastMessage,
          lastChangeTimestamp,
          unreadCount,
          open,
          muted,
          encrypted,
          favourited,
          contactID,
          contactDisplayName,
          contactAvatarPath,
          contactAvatarHash,
          chatState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_Chat value) $default, {
    required TResult Function(_ChatFromDb value) fromDb,
  }) {
    return fromDb(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_Chat value)? $default, {
    TResult? Function(_ChatFromDb value)? fromDb,
  }) {
    return fromDb?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_Chat value)? $default, {
    TResult Function(_ChatFromDb value)? fromDb,
    required TResult orElse(),
  }) {
    if (fromDb != null) {
      return fromDb(this);
    }
    return orElse();
  }
}

abstract class _ChatFromDb extends Chat {
  const factory _ChatFromDb(
      {required final String jid,
      required final String myJid,
      required final String myNickname,
      required final String title,
      required final ChatType type,
      required final String? avatarPath,
      required final String? avatarHash,
      required final String? lastMessage,
      required final DateTime lastChangeTimestamp,
      required final int unreadCount,
      required final bool open,
      required final bool muted,
      required final bool encrypted,
      required final bool favourited,
      required final String? contactID,
      required final String? contactDisplayName,
      required final String? contactAvatarPath,
      required final String? contactAvatarHash,
      final mox.ChatState? chatState}) = _$ChatFromDbImpl;
  const _ChatFromDb._() : super._();

  @override
  String get jid;
  @override
  String get myJid;
  @override
  String get myNickname;
  @override
  String get title;
  @override
  ChatType get type;
  @override
  String? get avatarPath;
  @override
  String? get avatarHash;
  @override
  String? get lastMessage;
  @override
  DateTime get lastChangeTimestamp;
  @override
  int get unreadCount;
  @override
  bool get open;
  @override
  bool get muted;
  @override
  bool get encrypted;
  @override
  bool get favourited;
  @override
  String? get contactID;
  @override
  String? get contactDisplayName;
  @override
  String? get contactAvatarPath;
  @override
  String? get contactAvatarHash;
  @override
  mox.ChatState? get chatState;
  @override
  @JsonKey(ignore: true)
  _$$ChatFromDbImplCopyWith<_$ChatFromDbImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Sticker {
  String get id => throw _privateConstructorUsedError;
  String get stickerPackID => throw _privateConstructorUsedError;
  String get fileMetadataID => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  Map<String, String> get suggestions => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StickerCopyWith<Sticker> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StickerCopyWith<$Res> {
  factory $StickerCopyWith(Sticker value, $Res Function(Sticker) then) =
      _$StickerCopyWithImpl<$Res, Sticker>;
  @useResult
  $Res call(
      {String id,
      String stickerPackID,
      String fileMetadataID,
      String description,
      Map<String, String> suggestions});
}

/// @nodoc
class _$StickerCopyWithImpl<$Res, $Val extends Sticker>
    implements $StickerCopyWith<$Res> {
  _$StickerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? stickerPackID = null,
    Object? fileMetadataID = null,
    Object? description = null,
    Object? suggestions = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      stickerPackID: null == stickerPackID
          ? _value.stickerPackID
          : stickerPackID // ignore: cast_nullable_to_non_nullable
              as String,
      fileMetadataID: null == fileMetadataID
          ? _value.fileMetadataID
          : fileMetadataID // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      suggestions: null == suggestions
          ? _value.suggestions
          : suggestions // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StickerImplCopyWith<$Res> implements $StickerCopyWith<$Res> {
  factory _$$StickerImplCopyWith(
          _$StickerImpl value, $Res Function(_$StickerImpl) then) =
      __$$StickerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String stickerPackID,
      String fileMetadataID,
      String description,
      Map<String, String> suggestions});
}

/// @nodoc
class __$$StickerImplCopyWithImpl<$Res>
    extends _$StickerCopyWithImpl<$Res, _$StickerImpl>
    implements _$$StickerImplCopyWith<$Res> {
  __$$StickerImplCopyWithImpl(
      _$StickerImpl _value, $Res Function(_$StickerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? stickerPackID = null,
    Object? fileMetadataID = null,
    Object? description = null,
    Object? suggestions = null,
  }) {
    return _then(_$StickerImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      stickerPackID: null == stickerPackID
          ? _value.stickerPackID
          : stickerPackID // ignore: cast_nullable_to_non_nullable
              as String,
      fileMetadataID: null == fileMetadataID
          ? _value.fileMetadataID
          : fileMetadataID // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      suggestions: null == suggestions
          ? _value._suggestions
          : suggestions // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc

class _$StickerImpl implements _Sticker {
  const _$StickerImpl(
      {required this.id,
      required this.stickerPackID,
      required this.fileMetadataID,
      required this.description,
      required final Map<String, String> suggestions})
      : _suggestions = suggestions;

  @override
  final String id;
  @override
  final String stickerPackID;
  @override
  final String fileMetadataID;
  @override
  final String description;
  final Map<String, String> _suggestions;
  @override
  Map<String, String> get suggestions {
    if (_suggestions is EqualUnmodifiableMapView) return _suggestions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_suggestions);
  }

  @override
  String toString() {
    return 'Sticker(id: $id, stickerPackID: $stickerPackID, fileMetadataID: $fileMetadataID, description: $description, suggestions: $suggestions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StickerImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.stickerPackID, stickerPackID) ||
                other.stickerPackID == stickerPackID) &&
            (identical(other.fileMetadataID, fileMetadataID) ||
                other.fileMetadataID == fileMetadataID) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._suggestions, _suggestions));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      stickerPackID,
      fileMetadataID,
      description,
      const DeepCollectionEquality().hash(_suggestions));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StickerImplCopyWith<_$StickerImpl> get copyWith =>
      __$$StickerImplCopyWithImpl<_$StickerImpl>(this, _$identity);
}

abstract class _Sticker implements Sticker {
  const factory _Sticker(
      {required final String id,
      required final String stickerPackID,
      required final String fileMetadataID,
      required final String description,
      required final Map<String, String> suggestions}) = _$StickerImpl;

  @override
  String get id;
  @override
  String get stickerPackID;
  @override
  String get fileMetadataID;
  @override
  String get description;
  @override
  Map<String, String> get suggestions;
  @override
  @JsonKey(ignore: true)
  _$$StickerImplCopyWith<_$StickerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StickerPack {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  String get hashAlgorithm => throw _privateConstructorUsedError;
  String get hashValue => throw _privateConstructorUsedError;
  bool get restricted => throw _privateConstructorUsedError;
  DateTime get addedTimestamp => throw _privateConstructorUsedError;
  List<Sticker> get stickers => throw _privateConstructorUsedError;
  int get sizeBytes => throw _privateConstructorUsedError;
  bool get local => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StickerPackCopyWith<StickerPack> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StickerPackCopyWith<$Res> {
  factory $StickerPackCopyWith(
          StickerPack value, $Res Function(StickerPack) then) =
      _$StickerPackCopyWithImpl<$Res, StickerPack>;
  @useResult
  $Res call(
      {String id,
      String name,
      String description,
      String hashAlgorithm,
      String hashValue,
      bool restricted,
      DateTime addedTimestamp,
      List<Sticker> stickers,
      int sizeBytes,
      bool local});
}

/// @nodoc
class _$StickerPackCopyWithImpl<$Res, $Val extends StickerPack>
    implements $StickerPackCopyWith<$Res> {
  _$StickerPackCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? hashAlgorithm = null,
    Object? hashValue = null,
    Object? restricted = null,
    Object? addedTimestamp = null,
    Object? stickers = null,
    Object? sizeBytes = null,
    Object? local = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      hashAlgorithm: null == hashAlgorithm
          ? _value.hashAlgorithm
          : hashAlgorithm // ignore: cast_nullable_to_non_nullable
              as String,
      hashValue: null == hashValue
          ? _value.hashValue
          : hashValue // ignore: cast_nullable_to_non_nullable
              as String,
      restricted: null == restricted
          ? _value.restricted
          : restricted // ignore: cast_nullable_to_non_nullable
              as bool,
      addedTimestamp: null == addedTimestamp
          ? _value.addedTimestamp
          : addedTimestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      stickers: null == stickers
          ? _value.stickers
          : stickers // ignore: cast_nullable_to_non_nullable
              as List<Sticker>,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      local: null == local
          ? _value.local
          : local // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StickerPackImplCopyWith<$Res>
    implements $StickerPackCopyWith<$Res> {
  factory _$$StickerPackImplCopyWith(
          _$StickerPackImpl value, $Res Function(_$StickerPackImpl) then) =
      __$$StickerPackImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String description,
      String hashAlgorithm,
      String hashValue,
      bool restricted,
      DateTime addedTimestamp,
      List<Sticker> stickers,
      int sizeBytes,
      bool local});
}

/// @nodoc
class __$$StickerPackImplCopyWithImpl<$Res>
    extends _$StickerPackCopyWithImpl<$Res, _$StickerPackImpl>
    implements _$$StickerPackImplCopyWith<$Res> {
  __$$StickerPackImplCopyWithImpl(
      _$StickerPackImpl _value, $Res Function(_$StickerPackImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? hashAlgorithm = null,
    Object? hashValue = null,
    Object? restricted = null,
    Object? addedTimestamp = null,
    Object? stickers = null,
    Object? sizeBytes = null,
    Object? local = null,
  }) {
    return _then(_$StickerPackImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      hashAlgorithm: null == hashAlgorithm
          ? _value.hashAlgorithm
          : hashAlgorithm // ignore: cast_nullable_to_non_nullable
              as String,
      hashValue: null == hashValue
          ? _value.hashValue
          : hashValue // ignore: cast_nullable_to_non_nullable
              as String,
      restricted: null == restricted
          ? _value.restricted
          : restricted // ignore: cast_nullable_to_non_nullable
              as bool,
      addedTimestamp: null == addedTimestamp
          ? _value.addedTimestamp
          : addedTimestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      stickers: null == stickers
          ? _value._stickers
          : stickers // ignore: cast_nullable_to_non_nullable
              as List<Sticker>,
      sizeBytes: null == sizeBytes
          ? _value.sizeBytes
          : sizeBytes // ignore: cast_nullable_to_non_nullable
              as int,
      local: null == local
          ? _value.local
          : local // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$StickerPackImpl implements _StickerPack {
  const _$StickerPackImpl(
      {required this.id,
      required this.name,
      required this.description,
      required this.hashAlgorithm,
      required this.hashValue,
      required this.restricted,
      required this.addedTimestamp,
      final List<Sticker> stickers = const <Sticker>[],
      this.sizeBytes = 0,
      this.local = true})
      : _stickers = stickers;

  @override
  final String id;
  @override
  final String name;
  @override
  final String description;
  @override
  final String hashAlgorithm;
  @override
  final String hashValue;
  @override
  final bool restricted;
  @override
  final DateTime addedTimestamp;
  final List<Sticker> _stickers;
  @override
  @JsonKey()
  List<Sticker> get stickers {
    if (_stickers is EqualUnmodifiableListView) return _stickers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_stickers);
  }

  @override
  @JsonKey()
  final int sizeBytes;
  @override
  @JsonKey()
  final bool local;

  @override
  String toString() {
    return 'StickerPack(id: $id, name: $name, description: $description, hashAlgorithm: $hashAlgorithm, hashValue: $hashValue, restricted: $restricted, addedTimestamp: $addedTimestamp, stickers: $stickers, sizeBytes: $sizeBytes, local: $local)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StickerPackImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.hashAlgorithm, hashAlgorithm) ||
                other.hashAlgorithm == hashAlgorithm) &&
            (identical(other.hashValue, hashValue) ||
                other.hashValue == hashValue) &&
            (identical(other.restricted, restricted) ||
                other.restricted == restricted) &&
            (identical(other.addedTimestamp, addedTimestamp) ||
                other.addedTimestamp == addedTimestamp) &&
            const DeepCollectionEquality().equals(other._stickers, _stickers) &&
            (identical(other.sizeBytes, sizeBytes) ||
                other.sizeBytes == sizeBytes) &&
            (identical(other.local, local) || other.local == local));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      description,
      hashAlgorithm,
      hashValue,
      restricted,
      addedTimestamp,
      const DeepCollectionEquality().hash(_stickers),
      sizeBytes,
      local);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StickerPackImplCopyWith<_$StickerPackImpl> get copyWith =>
      __$$StickerPackImplCopyWithImpl<_$StickerPackImpl>(this, _$identity);
}

abstract class _StickerPack implements StickerPack {
  const factory _StickerPack(
      {required final String id,
      required final String name,
      required final String description,
      required final String hashAlgorithm,
      required final String hashValue,
      required final bool restricted,
      required final DateTime addedTimestamp,
      final List<Sticker> stickers,
      final int sizeBytes,
      final bool local}) = _$StickerPackImpl;

  @override
  String get id;
  @override
  String get name;
  @override
  String get description;
  @override
  String get hashAlgorithm;
  @override
  String get hashValue;
  @override
  bool get restricted;
  @override
  DateTime get addedTimestamp;
  @override
  List<Sticker> get stickers;
  @override
  int get sizeBytes;
  @override
  bool get local;
  @override
  @JsonKey(ignore: true)
  _$$StickerPackImplCopyWith<_$StickerPackImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
